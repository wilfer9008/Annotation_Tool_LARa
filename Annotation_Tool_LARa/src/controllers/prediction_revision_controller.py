'''
Created on 23.07.2020

@author: Erik Altermann
@email: Erik.Altermann@tu-dortmund.de
'''

from PyQt5 import QtWidgets
import pyqtgraph as pg

import global_variables as g
from .controller import Controller,Graph

class Prediction_Revision_Controller(Controller):
    def __init__(self, gui):
        Controller.__init__(self, gui)
        
        self.was_enabled_once = False
        
        self.current_window = -1
        self.current_window_0 = -1
        self.setup_widgets()
        
    def setup_widgets(self):
        #---------Labels-----------
        self.current_class_label = self.gui.get_widget(QtWidgets.QLabel,'pr_current_class_label')
        self.first_class_label = self.gui.get_widget(QtWidgets.QLabel,'pr_1st_class_label')
        self.second_class_label = self.gui.get_widget(QtWidgets.QLabel,'pr_2nd_class_label')
        self.third_class_label = self.gui.get_widget(QtWidgets.QLabel,'pr_3rd_class_label')
        
        #------Choice Buttons----
        self.choose_first_button = self.gui.get_widget(QtWidgets.QPushButton,'pr_choose_1st_button')
        self.choose_first_button.clicked.connect(lambda _: self.choose_n_th_prediction(0))
        self.choose_second_button = self.gui.get_widget(QtWidgets.QPushButton,'pr_choose_2nd_button')
        self.choose_second_button.clicked.connect(lambda _: self.choose_n_th_prediction(1))
        self.choose_third_button = self.gui.get_widget(QtWidgets.QPushButton,'pr_choose_3rd_button')
        self.choose_third_button.clicked.connect(lambda _: self.choose_n_th_prediction(2))
        #------Other Buttons-----
        self.use_predictions_button = self.gui.get_widget(QtWidgets.QPushButton,'pr_use_predictions_button')
        self.use_predictions_button.clicked.connect(lambda _: self.gui.pause())
        self.use_predictions_button.clicked.connect(lambda _: self.use_predictions())
        self.toggle_error_button = self.gui.get_widget(QtWidgets.QPushButton,'pr_toggle_error_button')
        self.toggle_error_button.clicked.connect(lambda _: self.toggle_error())
        self.set_all_error_button = self.gui.get_widget(QtWidgets.QPushButton,'pr_set_all_error_button')
        self.set_all_error_button.clicked.connect(lambda _: self.set_all_error())
        #---------Graphs---------
        self.class_graph_0 = self.gui.get_widget(pg.PlotWidget, 'pr_classGraph_0')
        self.class_graph_1 = self.gui.get_widget(pg.PlotWidget, 'pr_classGraph_1')
        self.class_graph_2 = self.gui.get_widget(pg.PlotWidget, 'pr_classGraph_2')
        self.class_graph_3 = self.gui.get_widget(pg.PlotWidget, 'pr_classGraph_3')
        self.attribute_graph = self.gui.get_widget(pg.PlotWidget, 'pr_attributeGraph')
        
        #------Status window-----
        self.statusWindow = self.gui.get_widget(QtWidgets.QTextEdit, 'pr_statusWindow')
        self.add_status_message("This mode is for choosing the correct label out of all generated by the automatic annotation")
        
    def enable_widgets(self):
        if not self.was_enabled_once:
            self.class_graph_0 = Graph(self.class_graph_0, 'class', 
                                    interval_lines=False, label='Classes')
            self.class_graph_1 = Graph(self.class_graph_1, 'class', 
                                    interval_lines=False, label='Classes #1')
            self.class_graph_2 = Graph(self.class_graph_2, 'class', 
                                    interval_lines=False, label='Classes #2')
            self.class_graph_3 = Graph(self.class_graph_3, 'class', 
                                    interval_lines=False, label='Classes #3')
            self.attribute_graph = Graph(self.attribute_graph, 'attribute',
                                    interval_lines = False)
            self.was_enabled_once = True
            
        
        self.class_graph_0.setup()
        #self.class_graph_0.reload_classes(g.data.windows)
        self.class_graph_1.setup()
        #self.class_graph_1.reload_classes(g.data.windows_1)
        self.class_graph_2.setup()
        #self.class_graph_2.reload_classes(g.data.windows_2)
        self.class_graph_3.setup()
        #self.class_graph_3.reload_classes(g.data.windows_3)
        self.attribute_graph.setup()
        
        self.reload()
            
            
            
    def reload(self):
        #print("reloading prediction revision mode")
        frame = self.gui.get_current_frame()
        
        if g.data is not None: 
            self.class_graph_0.reload_classes(g.data.windows)
            
        graphs = [self.class_graph_0, self.class_graph_1, 
                  self.class_graph_2, self.class_graph_3]
        for graph in graphs:
                graph.update_frame_lines(play=frame)
        
        
        
        if g.data is not None \
                and g.data.windows_1 is not None \
                and g.data.windows_1.__len__() >0:
            
            graphs = [self.class_graph_1, self.class_graph_2, self.class_graph_3]
            windows = [g.data.windows_1, g.data.windows_2, g.data.windows_3]
            for graph,window in zip(graphs,windows):
                graph.reload_classes(window)
                
            self.select_window_by_frame(frame)
            self.highlight_class_bar(self.current_window)
            self.update_labels()
            self.use_predictions_button.setEnabled(True)
        else:
            self.use_predictions_button.setEnabled(False)
        
        
        
    def new_frame(self, frame):
        classgraphs = [self.class_graph_0, self.class_graph_1, \
                       self.class_graph_2, self.class_graph_3]
        for graph in classgraphs:
            graph.update_frame_lines(play=frame)
        
        if g.data is not None \
                and g.data.windows_1 is not None \
                and g.data.windows_1.__len__() >0:
            
            window_0_index, window_1_index = self.class_window_index(frame)
            if self.current_window != window_1_index:
                self.current_window_0 = window_0_index
                self.current_window = window_1_index
                self.selectWindow(window_0_index, window_1_index)
                self.highlight_class_bar(self.current_window)   
    

    def class_window_index(self,frame):
        """"""
        if frame is None:
            frame = self.gui.get_current_frame()
        #print("class_window_index")
        class_0_index = None
        class_1_index = None
        if g.data.windows is not None:
            for i, window in enumerate(g.data.windows):
                #print("checking window", i)
                if window[0] <= frame and frame < window[1]:
                    #return i
                    class_0_index = i
                    #print("class_0_index", class_0_index)
                    break
        if g.data.windows_1 is not None:
            for j, window in enumerate(g.data.windows_1):
                if window[0] <= frame and frame < window[1]:
                    #return j
                    class_1_index = j
                    break
        return class_0_index,class_1_index
    
    def select_window_by_frame(self,frame=None):
        """Selects the Window around based on the current Frame shown
        
        """
        if frame is None:
            frame = self.gui.get_current_frame()
        window_0_index, window_1_index = self.class_window_index(frame)
        if window_0_index is None:
            window_0_index = -1
        if window_1_index is None:
            window_1_index = -1
        #if the old and new index is the same do nothing.
        if self.current_window != window_1_index \
                or self.current_window_0 != window_0_index:
            
            self.current_window = window_1_index
            self.current_window_0 = window_0_index
            self.selectWindow(window_0_index, window_1_index)
            
        else:
            self.current_window = window_1_index
    
    def selectWindow(self,window_0_index:int,window_1_index:int):
        """Selects the window at window_index"""
        if window_0_index >= 0:
            self.current_window_0 = window_0_index

        if window_1_index >= 0:
            self.current_window = window_1_index
                
            #needs to update shown attributes and start-, end-lines for top3 graphs
            #start end and attributes are the same in each prediction
            
            #classgraphs = [self.class_graph_1, self.class_graph_2, self.class_graph_3]
            #for graph in classgraphs:
                #graph.update_frame_lines(start, end)
            
            _, _, _, attributes = g.data.windows_1[self.current_window]
            
            self.attribute_graph.update_attributes(attributes)
        
        self.update_labels()
    
    def update_labels(self):
        if self.current_window_0 >= 0:
            _, _, class_0, _ = g.data.windows[self.current_window_0]
            self.current_class_label.setText(g.data.classes[class_0])
        
        
        if self.current_window >= 0:
            _, _, class_1, _ = g.data.windows_1[self.current_window]
            _, _, class_2, _ = g.data.windows_2[self.current_window]
            _, _, class_3, _ = g.data.windows_3[self.current_window]
            
            self.first_class_label.setText(g.data.classes[class_1])
            self.second_class_label.setText(g.data.classes[class_2])
            self.third_class_label.setText(g.data.classes[class_3])
            
    
    def highlight_class_bar(self, bar_index):
        """"""
        
        normal_color = 0.5 #gray
        error_color = 200,100,100 #gray-ish red
        selected_color = 'y' #yellow
        selected_error_color = 255,200,50 #orange
        
        num_windows = g.data.windows_1.__len__()
        
        colors = []
        for i in range(num_windows):
            if g.data.windows_1[i][3][-1] == 0:
                colors.append(normal_color)
            else:
                colors.append(error_color)
        
        if (bar_index is not None) :
            if (g.data.windows_1[bar_index][3][-1] == 0):
                colors[bar_index] = selected_color
            else:
                colors[bar_index] = selected_error_color
        
        self.class_graph_1.color_class_bars(colors)
        self.class_graph_2.color_class_bars(colors)
        self.class_graph_3.color_class_bars(colors)

        if self.revision_mode_enabled:
            colors = Controller.highlight_class_bar(self, bar_index)
            self.class_graph_0.color_class_bars(colors)
        else:
            colors = Controller.highlight_class_bar(self, None)
            self.class_graph_0.color_class_bars(colors)

    def use_predictions(self):
        
        message = "This action will enable revision mode.\n\
Any labeling done up to this point will be discarded and instead the first prediction will be used.\n\
Some features in other modes will be disabled until revision mode is disabled again.\n\
You can choose between the top3 classes in here or change the labels in label correction mode."
            
        revision_mode_warning = QtWidgets.QMessageBox.question(
            self.gui, 'Start revision mode?', message, 
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel, 
            QtWidgets.QMessageBox.Cancel)
        
        if revision_mode_warning == QtWidgets.QMessageBox.Yes:
            self.gui.revision_mode(True)
            
            
    def disable_revision_mode(self):
        message = "This will disable revision mode.\n\
Make sure you are finished everything you need to do in this mode.\n\
Next time you activate revision mode your unsaved progress will be lost"
            
        revision_mode_warning = QtWidgets.QMessageBox.question(
            self.gui, 'Stop revision mode?', message, 
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel, 
            QtWidgets.QMessageBox.Cancel)
        
        if revision_mode_warning == QtWidgets.QMessageBox.Yes:
            self.gui.revision_mode(False)
        
    
    def revision_mode(self, enable:bool):
        self.revision_mode_enabled = enable
        
        self.choose_first_button.setEnabled(enable)
        self.choose_second_button.setEnabled(enable)
        self.choose_third_button.setEnabled(enable)
        self.toggle_error_button.setEnabled(enable)
        self.set_all_error_button.setEnabled(enable)
        
        if enable:
            g.data.windows = [(s,e,c,[a for a in A]) for (s,e,c,A) in g.data.windows_1]
            g.data.saveWindows()
            self.use_predictions_button.clicked.disconnect()
            self.use_predictions_button.clicked.connect(lambda _: self.disable_revision_mode())
            self.use_predictions_button.setText("Stop revision mode")
                                                
        else:
            self.use_predictions_button.clicked.disconnect()
            self.use_predictions_button.clicked.connect(lambda _: self.use_predictions())
            self.use_predictions_button.setText("Use 1st Predictions")
                                                
        self.reload()


    def choose_n_th_prediction(self,n):
        predictions = [g.data.windows_1, g.data.windows_2, g.data.windows_3]
        
        s, e, c, A = predictions[n][self.current_window]
        g.data.windows[self.current_window] = (s,e,c,[a for a in A])
        g.data.windows[self.current_window][3][-1] = 1
        self.reload()
        
    def toggle_error(self):
        #print("toggling error")

        #prediction[self.current_window][3][-1] = 1 - prediction[self.current_window][3][-1]
        g.data.windows[self.current_window][3][-1] = 1 \
            - g.data.windows[self.current_window][3][-1]
        
        self.reload()
        
    def set_all_error(self):
        
        
        for i in range(g.data.windows.__len__()):
            g.data.windows[i][3][-1] = 1
        
        self.reload()
    
    
    def get_start_frame(self) -> int:
        """returns the start of the current window"""
        
        if g.data.windows_1 is not None and g.data.windows_1.__len__() > 0:
            return g.data.windows_1[self.current_window][0]+1
        return self.gui.get_current_frame()
    
    