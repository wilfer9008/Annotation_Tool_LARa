"""
Created on 23.07.2020

@author: Erik Altermann
@email: Erik.Altermann@tu-dortmund.de
"""

from PyQt5 import QtWidgets
from os import sep
import pyqtgraph as pg

import global_variables as g
from .controller import Controller, Graph


class PredictionRevisionController(Controller):
    def __init__(self, gui):
        Controller.__init__(self, gui)

        self.was_enabled_once = False

        self.current_window = -1
        self.current_window_0 = -1
        self.setup_widgets()

    def setup_widgets(self):
        self.load_tab(f'..{sep}ui{sep}prediction_revision_mode.ui', "Prediction Revision")
        # ---------Labels-----------
        self.current_class_label = self.widget.findChild(QtWidgets.QLabel, 'pr_current_class_label')
        self.first_class_label = self.widget.findChild(QtWidgets.QLabel, 'pr_1st_class_label')
        self.second_class_label = self.widget.findChild(QtWidgets.QLabel, 'pr_2nd_class_label')
        self.third_class_label = self.widget.findChild(QtWidgets.QLabel, 'pr_3rd_class_label')

        # ------Choice Buttons----
        self.choose_first_button = self.widget.findChild(QtWidgets.QPushButton, 'pr_choose_1st_button')
        self.choose_first_button.clicked.connect(lambda _: self.choose_n_th_prediction(0))
        self.choose_second_button = self.widget.findChild(QtWidgets.QPushButton, 'pr_choose_2nd_button')
        self.choose_second_button.clicked.connect(lambda _: self.choose_n_th_prediction(1))
        self.choose_third_button = self.widget.findChild(QtWidgets.QPushButton, 'pr_choose_3rd_button')
        self.choose_third_button.clicked.connect(lambda _: self.choose_n_th_prediction(2))
        # ------Other Buttons-----
        self.use_predictions_button = self.widget.findChild(QtWidgets.QPushButton, 'pr_use_predictions_button')
        self.use_predictions_button.clicked.connect(lambda _: self.gui.pause())
        self.use_predictions_button.clicked.connect(lambda _: self.use_predictions())
        self.toggle_error_button = self.widget.findChild(QtWidgets.QPushButton, 'pr_toggle_error_button')
        self.toggle_error_button.clicked.connect(lambda _: self.toggle_error())
        self.set_all_error_button = self.widget.findChild(QtWidgets.QPushButton, 'pr_set_all_error_button')
        self.set_all_error_button.clicked.connect(lambda _: self.set_all_error())
        # ---------Graphs---------
        self.class_graph_0 = self.widget.findChild(pg.PlotWidget, 'pr_classGraph_0')
        self.class_graph_1 = self.widget.findChild(pg.PlotWidget, 'pr_classGraph_1')
        self.class_graph_2 = self.widget.findChild(pg.PlotWidget, 'pr_classGraph_2')
        self.class_graph_3 = self.widget.findChild(pg.PlotWidget, 'pr_classGraph_3')
        self.attribute_graph = self.widget.findChild(pg.PlotWidget, 'pr_attributeGraph')

        # ------Status window-----
        self.status_window = self.widget.findChild(QtWidgets.QTextEdit, 'pr_statusWindow')
        self.add_status_message(
            "This mode is for choosing the correct label out of all generated by the automatic annotation")

    def enable_widgets(self):
        if not self.was_enabled_once:
            self.class_graph_0 = Graph(self.class_graph_0, 'class',
                                       interval_lines=False, label='Classes')
            self.class_graph_1 = Graph(self.class_graph_1, 'class',
                                       interval_lines=False, label='Classes #1')
            self.class_graph_2 = Graph(self.class_graph_2, 'class',
                                       interval_lines=False, label='Classes #2')
            self.class_graph_3 = Graph(self.class_graph_3, 'class',
                                       interval_lines=False, label='Classes #3')
            self.attribute_graph = Graph(self.attribute_graph, 'attribute',
                                         interval_lines=False)
            self.was_enabled_once = True

        self.class_graph_0.setup()
        # self.class_graph_0.reload_classes(g.windows.windows)
        self.class_graph_1.setup()
        # self.class_graph_1.reload_classes(g.windows.windows_1)
        self.class_graph_2.setup()
        # self.class_graph_2.reload_classes(g.windows.windows_2)
        self.class_graph_3.setup()
        # self.class_graph_3.reload_classes(g.windows.windows_3)
        self.attribute_graph.setup()

        self.reload()

    def reload(self):
        # print("reloading prediction revision mode")
        frame = self.gui.get_current_frame()

        if g.windows is not None:
            self.class_graph_0.reload_classes(g.windows.windows)

        graphs = [self.class_graph_0, self.class_graph_1,
                  self.class_graph_2, self.class_graph_3]
        for graph in graphs:
            graph.update_frame_lines(play=frame)

        if g.windows is not None \
                and g.windows.windows_1 is not None \
                and len(g.windows.windows_1) > 0:

            graphs = [self.class_graph_1, self.class_graph_2, self.class_graph_3]
            windows = [g.windows.windows_1, g.windows.windows_2, g.windows.windows_3]
            for graph, window in zip(graphs, windows):
                graph.reload_classes(window)

            self.select_window_by_frame(frame)
            self.highlight_class_bar(self.current_window)
            self.update_labels()

            if self.fixed_window_mode_enabled in [None, "none", "prediction_revision"]:
                self.use_predictions_button.setEnabled(True)
        else:
            self.use_predictions_button.setEnabled(False)

    def new_frame(self, frame):
        classgraphs = [self.class_graph_0, self.class_graph_1, self.class_graph_2, self.class_graph_3]
        for graph in classgraphs:
            graph.update_frame_lines(play=frame)

        if g.windows is not None \
                and g.windows.windows_1 is not None \
                and len(g.windows.windows_1) > 0:

            window_0_index, window_1_index = self.class_window_index(frame)
            if self.current_window != window_1_index:
                self.current_window_0 = window_0_index
                self.current_window = window_1_index
                self.select_window(window_0_index, window_1_index)
                self.highlight_class_bar(self.current_window)

    def class_window_index(self, frame):
        """"""
        if frame is None:
            frame = self.gui.get_current_frame()
        # print("class_window_index")
        class_0_index = None
        class_1_index = None
        if g.windows.windows is not None:
            for i, window in enumerate(g.windows.windows):
                # print("checking window", i)
                if window[0] <= frame < window[1]:
                    # return i
                    class_0_index = i
                    # print("class_0_index", class_0_index)
                    break
        if g.windows.windows_1 is not None:
            for j, window in enumerate(g.windows.windows_1):
                if window[0] <= frame < window[1]:
                    # return j
                    class_1_index = j
                    break
        return class_0_index, class_1_index

    def select_window_by_frame(self, frame=None):
        """Selects the Window around based on the current Frame shown
        
        """
        if frame is None:
            frame = self.gui.get_current_frame()
        window_0_index, window_1_index = self.class_window_index(frame)
        if window_0_index is None:
            window_0_index = -1
        if window_1_index is None:
            window_1_index = -1
        # if the old and new index is the same do nothing.
        if self.current_window != window_1_index \
                or self.current_window_0 != window_0_index:

            self.current_window = window_1_index
            self.current_window_0 = window_0_index
            self.select_window(window_0_index, window_1_index)

        else:
            self.current_window = window_1_index

    def select_window(self, window_0_index: int, window_1_index: int):
        """Selects the window at window_index"""
        if window_0_index >= 0:
            self.current_window_0 = window_0_index

        if window_1_index >= 0:
            self.current_window = window_1_index

            # needs to update shown attributes and start-, end-lines for top3 graphs
            # start end and attributes are the same in each prediction

            # classgraphs = [self.class_graph_1, self.class_graph_2, self.class_graph_3]
            # for graph in classgraphs:
            # graph.update_frame_lines(start, end)

            _, _, _, attributes = g.windows.windows_1[self.current_window]

            self.attribute_graph.update_attributes(attributes)

        self.update_labels()

    def update_labels(self):
        if self.current_window_0 >= 0:
            _, _, class_0, _ = g.windows.windows[self.current_window_0]
            self.current_class_label.setText(g.classes[class_0])

        if self.current_window >= 0:
            _, _, class_1, _ = g.windows.windows_1[self.current_window]
            _, _, class_2, _ = g.windows.windows_2[self.current_window]
            _, _, class_3, _ = g.windows.windows_3[self.current_window]

            self.first_class_label.setText(g.classes[class_1])
            self.second_class_label.setText(g.classes[class_2])
            self.third_class_label.setText(g.classes[class_3])

    def highlight_class_bar(self, bar_index):
        """"""

        normal_color = 0.5  # gray
        error_color = 200, 100, 100  # gray-ish red
        selected_color = 'y'  # yellow
        selected_error_color = 255, 200, 50  # orange

        num_windows = len(g.windows.windows_1)

        colors = []
        for i in range(num_windows):
            if g.windows.windows_1[i][3][-1] == 0:
                colors.append(normal_color)
            else:
                colors.append(error_color)

        if bar_index is not None:
            if g.windows.windows_1[bar_index][3][-1] == 0:
                colors[bar_index] = selected_color
            else:
                colors[bar_index] = selected_error_color

        self.class_graph_1.color_class_bars(colors)
        self.class_graph_2.color_class_bars(colors)
        self.class_graph_3.color_class_bars(colors)

        if self.fixed_window_mode_enabled == "prediction_revision":
            colors = Controller.highlight_class_bar(self, bar_index)
            self.class_graph_0.color_class_bars(colors)
        else:
            colors = Controller.highlight_class_bar(self, None)
            self.class_graph_0.color_class_bars(colors)

    def use_predictions(self):

        message = "This action will enable fixed-window-size mode.\n\
Any labeling done up to this point will be discarded and instead the first prediction will be used.\n\
Some features in other modes will be disabled until fixed-window-size mode is disabled again.\n\
You can choose between the top3 classes in here or change the labels in label correction mode."

        revision_mode_warning = QtWidgets.QMessageBox.question(
            self.gui, 'Start fixed-window-size mode?', message,
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel,
            QtWidgets.QMessageBox.Cancel)

        if revision_mode_warning == QtWidgets.QMessageBox.Yes:
            g.windows.windows = [(s, e, c, [a for a in A]) for (s, e, c, A) in g.windows.windows_1]
            g.windows.make_backup()
            self.gui.fixed_windows_mode("prediction_revision")

    def disable_fixed_window_mode(self):
        message = "This will disable revision mode.\n\
Make sure you are finished everything you need to do in this mode.\n\
Next time you activate revision mode your unsaved progress will be lost"

        revision_mode_warning = QtWidgets.QMessageBox.question(
            self.gui, 'Stop revision mode?', message,
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel,
            QtWidgets.QMessageBox.Cancel)

        if revision_mode_warning == QtWidgets.QMessageBox.Yes:
            self.gui.fixed_windows_mode("none")

    def choose_n_th_prediction(self, n):
        predictions = [g.windows.windows_1, g.windows.windows_2, g.windows.windows_3]

        s, e, c, A = predictions[n][self.current_window]
        g.windows.windows[self.current_window] = (s, e, c, [a for a in A])
        g.windows.windows[self.current_window][3][-1] = 1
        self.reload()

    def fixed_windows_mode(self, mode: str):
        self.fixed_window_mode_enabled = mode

        if mode == "prediction_revision":
            enable = True
        else:
            enable = False

        self.choose_first_button.setEnabled(enable)
        self.choose_second_button.setEnabled(enable)
        self.choose_third_button.setEnabled(enable)
        self.toggle_error_button.setEnabled(enable)
        self.set_all_error_button.setEnabled(enable)

        if enable:
            self.use_predictions_button.clicked.disconnect()
            self.use_predictions_button.clicked.connect(lambda _: self.disable_fixed_window_mode())
            self.use_predictions_button.setText("Stop revision mode")
        elif mode is None or mode == "none":
            self.use_predictions_button.clicked.disconnect()
            self.use_predictions_button.clicked.connect(lambda _: self.use_predictions())
            self.use_predictions_button.setText("Use 1st Predictions")
            self.use_predictions_button.setEnabled(True)
        else:
            self.use_predictions_button.setEnabled(False)
        self.reload()

    def toggle_error(self):
        # print("toggling error")

        # prediction[self.current_window][3][-1] = 1 - prediction[self.current_window][3][-1]
        g.windows.windows[self.current_window][3][-1] = 1 \
                                                        - g.windows.windows[self.current_window][3][-1]

        self.reload()

    def set_all_error(self):

        for i in range(len(g.windows.windows)):
            g.windows.windows[i][3][-1] = 1

        self.reload()

    def get_start_frame(self) -> int:
        """returns the start of the current window"""

        if g.windows.windows_1 is not None and len(g.windows.windows_1) > 0:
            return g.windows.windows_1[self.current_window][0] + 1
        return self.gui.get_current_frame()
